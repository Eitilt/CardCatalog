<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Metadata</name>
    </assembly>
    <members>
        <member name="T:Metadata.FieldDictionary">
            <summary>
            An alias for <see cref="T:System.Collections.Generic.Dictionary`2"/> to ensure the
            proper equality of keys to <see cref="T:Metadata.ITagField"/> objects.
            </summary>
        </member>
        <member name="T:Metadata.FieldDictionary.SequenceEqualityComparer`1">
            <summary>
            Test sequences for equality based on their values, not their
            object references.
            </summary>
            
            <remarks>
            Implementation from <see href="http://stackoverflow.com/a/7244729"/>.
            </remarks>
            
            <typeparam name="ElementType">
            The underlying type of the sequence.
            </typeparam>
        </member>
        <member name="F:Metadata.FieldDictionary.SequenceEqualityComparer`1.elementComparer">
            <summary>
            Provide a more robust meant of testing the equality of
            elements.
            </summary>
        </member>
        <member name="M:Metadata.FieldDictionary.SequenceEqualityComparer`1.Equals(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check two sequences for value equality.
            </summary>
            
            <returns>Whether the sequences are equal.</returns>
        </member>
        <member name="M:Metadata.FieldDictionary.SequenceEqualityComparer`1.GetHashCode(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Calculate a hash code based on the values of the sequence.
            </summary>
            
            <param name="obj">The sequence to hash.</param>
            
            <returns>The calculated hash.</returns>
        </member>
        <member name="F:Metadata.FieldDictionary.keyComparer">
            <summary>
            An instance of <see cref="T:Metadata.FieldDictionary.SequenceEqualityComparer`1"/>
            specialized to byte arrays.
            </summary>
        </member>
        <member name="M:Metadata.FieldDictionary.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Metadata.FieldDictionary"/>
            class that is empty and has the default initial capacity.
            </summary>
            
            <remarks>
            Every key in a <see cref="T:Metadata.FieldDictionary"/> must have a unique
            sequence of values.
            <para/>
            If you can estimate the size of the collection, using
            <see cref="M:Metadata.FieldDictionary.#ctor(System.Int32)"/> eliminates the need to perform
            a number of resizing operations while adding elements.
            <para/>
            This constructor is an O(1) operation.
            </remarks>
        </member>
        <member name="M:Metadata.FieldDictionary.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Metadata.FieldDictionary"/>
            class that is empty and has the specified initial capacity.
            </summary>
            
            <remarks>
            Every key in a <see cref="T:Metadata.FieldDictionary"/> must have a unique
            sequence of values.
            <para/>
            The capacity of a <see cref="T:Metadata.FieldDictionary"/> is the number of
            elements that can be added to the <see cref="T:Metadata.FieldDictionary"/>
            before resizing is necessary. As elements are added to a
            <see cref="T:Metadata.FieldDictionary"/>, the capacity is automatically
            increased as required by reallocating the internal array.
            Therefore, if the largest size of the collection can be estimated,
            specifying an initial capacity of that size or greater eliminates
            the need to perform a number of resizing operations while adding
            elements to the <see cref="T:Metadata.FieldDictionary"/>.
            <para/>
            This constructor is an O(1) operation.
            </remarks>
            
            <param name="capacity">
            The initial number of elements that the
            <see cref="T:Metadata.FieldDictionary"/> can contain.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="capacity"/> is less than 0.
            </exception>
        </member>
        <member name="M:Metadata.FieldDictionary.#ctor(Metadata.FieldDictionary)">
            <summary>
            Initializes a new instance of a <see cref="T:Metadata.FieldDictionary"/>
            that contains elements copied from <paramref name="dictionary"/>.
            </summary>
            
            <remarks>
            Every key in a <see cref="T:Metadata.FieldDictionary"/> must have a unique
            sequence of values; every key in <paramref name="dictionary"/>
            must therefore also have a unique sequence of values.
            <para/>
            IThe initial capacity of the new <see cref="T:Metadata.FieldDictionary"/> is
            large enough to contain all the elements in
            <paramref name="dictionary"/>.
            <para/>
            This constructor is an O(n) operation, where n is the number of
            elements in <paramref name="dictionary"/>.
            </remarks>
            
            <param name="dictionary">
            The <see cref="T:Metadata.FieldDictionary"/> whose elements are copied to the
            new <see cref="T:Metadata.FieldDictionary"/>.
            </param>
        </member>
        <member name="T:Metadata.IReadOnlyFieldDictionary">
            <summary>
            An alias for <see cref="T:System.Collections.Generic.Dictionary`2"/> to ensure the
            proper format for keys to <see cref="T:Metadata.ITagField"/> objects.
            </summary>
        </member>
        <member name="T:Metadata.MetadataFormat">
            <summary>
            A data-free class providing a common means to work with multiple
            metadata formats.
            </summary>
        </member>
        <member name="F:Metadata.MetadataFormat.tagValidationFunctions">
            <summary>
            Validation functions for each registered metadata format.
            </summary>
            <seealso cref="M:Metadata.MetadataFormat.Validate(System.String,System.IO.Stream)"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Validate(System.String,System.IO.Stream)">
            <summary>
            Check whether the stream begins with metadata in the desired
            format.
            </summary>
            <param name="format">
            The short name of the metadata format.
            </param>
            <param name="stream">The Stream to test.</param>
            <returns>
            Whether the Stream begins with metadata in the desired format.
            </returns>
            <seealso cref="M:Metadata.MetadataFormat.Parse(System.IO.Stream)"/>
        </member>
        <member name="F:Metadata.MetadataFormat.tagFormats">
            <summary>
            The class encapsulating each registered metadata format.
            </summary>
            <seealso cref="M:Metadata.MetadataFormat.FormatType(System.String)"/>
        </member>
        <member name="M:Metadata.MetadataFormat.FormatType(System.String)">
            <summary>
            Retrieve the class implementing the desired metadata format.
            </summary>
            <param name="format">
            The short name of the metadata format.
            </param>
            <returns>The class encapsulating the metadata format.</returns>
            <seealso cref="M:Metadata.MetadataFormat.Construct(System.String,System.IO.Stream)"/>
        </member>
        <member name="F:Metadata.MetadataFormat.assemblies">
            <summary>
            A registry of previously-scanned assemblies in order to prevent
            unnecessary use of reflection methods.
            </summary>
        </member>
        <member name="M:Metadata.MetadataFormat.#cctor">
            <summary>
            Initialize static attributes.
            </summary>
            <seealso cref="M:Metadata.MetadataFormat.RefreshFormats"/>
        </member>
        <member name="M:Metadata.MetadataFormat.RefreshFormats">
            <summary>
            Scan all currently-loaded assemblies for implementations of
            metadata formats.
            </summary>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.Reflection.Assembly)">
            <summary>
            Scan the given assembly for all types marked as implementing a
            metadata format in a suitable manner for automatic lookup.
            <para/>
            Subsequent calls on a previously-scanned assembly will be ignored
            in order to save unnecessary type reflection.
            </summary>
            <param name="assembly">The assembly to scan.</param>
            <seealso cref="T:Metadata.MetadataFormatAttribute"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.Type)">
            <summary>
            Add the given type to the lookup tables according to the descriptor
            specified in its <see cref="P:Metadata.MetadataFormatAttribute.Name"/>.
            </summary>
            <remarks>
            Note that if multiple types are registered under the same name,
            any later registrations will override the previous.
            </remarks>
            <param name="format">The type to add.</param>
            <seealso cref="T:Metadata.MetadataFormatValidatorAttribute"/>
            <seealso cref="M:Metadata.MetadataFormat.FormatType(System.String)"/>
            <seealso cref="M:Metadata.MetadataFormat.Validate(System.String,System.IO.Stream)"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.String,System.Type)">
            <summary>
            Add the given type to the lookup tables under the specified custom
            descriptor, even if it does not have any associated
            <see cref="T:Metadata.MetadataFormatAttribute"/>.
            </summary>
            <remarks>
            The validation function must still be identified with a
            <see cref="T:Metadata.MetadataFormatValidatorAttribute"/>.
            <para/>
            Note that if multiple types are registered under the same name,
            any later registrations will override the previous.
            </remarks>
            <param name="name">
            A short name for the format to be used as an access key for later
            lookups.
            <para/>
            It is recommended that this also be exposed as a constant.
            </param>
            <param name="format">The type to add.</param>
            <seealso cref="M:Metadata.MetadataFormat.FormatType(System.String)"/>
            <seealso cref="M:Metadata.MetadataFormat.Validate(System.String,System.IO.Stream)"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.String,System.Reflection.MethodInfo)">
            <summary>
            Add the given method to the lookup tables under the specified
            custom descriptor.
            <para/>
            This should almost purely be called via
            <see cref="M:Metadata.MetadataFormat.Register(System.String,System.Type)"/>, and has been separated
            primarily for code clarity.
            </summary>
            <remarks>
            Note that if multiple methods are registered under the same name,
            any later registrations will override the previous.
            </remarks>
            <param name="name">
            A short name for the format to be used as an access key for later
            lookups.
            </param>
            <param name="method">The method to add.</param>
        </member>
        <member name="M:Metadata.MetadataFormat.Parse(System.IO.Stream)">
            <summary>
            Check the stream against all registered tag formats, and return
            those that match the header.
            </summary>
            <remarks>
            While, in theory, only a single header should match, the class
            structure is such that this is not a restriction; supporting this
            feature allows for nonstandard usages without exclusive headers.
            
            The callee is left to determine the best means of handling the
            case of Detect(...).Count > 1.
            </remarks>
            <param name="stream">The bytestream to test.</param>
            <returns>The keys of all matching formats.</returns>
            <seealso cref="M:Metadata.MetadataFormat.Validate(System.String,System.IO.Stream)"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Construct(System.String,System.IO.Stream)">
            <summary>
            Parse metadata in the desired format from the current position in
            a stream.
            </summary>
            <param name="format">
            The short name of the metadata format.
            </param>
            <param name="stream">The bytestream to parse.</param>
            <returns>The parsed metadata.</returns>
            <seealso cref="M:Metadata.MetadataFormat.FormatType(System.String)"/>
        </member>
        <member name="T:Metadata.MetadataFormatAssemblyAttribute">
            <summary>
            Indicate that the assembly should be scanned for classes marked with
            <see cref="T:Metadata.MetadataFormatAttribute"/> to automatically register.
            
            This class cannot be inherited.
            </summary>
            <seealso cref="T:Metadata.MetadataFormatAttribute"/>
            <seealso cref="M:Metadata.MetadataFormat.Register(System.Reflection.Assembly)"/>
        </member>
        <member name="T:Metadata.MetadataFormatAttribute">
            <summary>
            Indicate that the class implements a metadata format specification.
            
            This class cannot be inherited.
            </summary>
            <remarks>
            The class must implement <see cref="T:Metadata.ITagFormat"/>.
            </remarks>
            <seealso cref="T:Metadata.MetadataFormatAssemblyAttribute"/>
            <seealso cref="M:Metadata.MetadataFormat.Register(System.String,System.Type)"/>
        </member>
        <member name="P:Metadata.MetadataFormatAttribute.Name">
            <summary>
            The unique short name representing this format.
            </summary>
        </member>
        <member name="M:Metadata.MetadataFormatAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Metadata.MetadataFormatAttribute"/> class with the specified
            <see cref="P:Metadata.MetadataFormatAttribute.Name"/>.
            </summary>
            <param name="name">
            The unique short name representing this format.
            <para/>
            It is recommended that this also be exposed as a constant on the
            type itself.
            </param>
        </member>
        <member name="T:Metadata.MetadataFormatValidatorAttribute">
            <summary>
            Marks a method as being a validation function checking a binary header
            against that defined by the enclosing metadata specification.
            
            This class cannot be inherited.
            </summary>
            <remarks>
            Note that this function must be able to accept only a
            <see cref="T:System.IO.Stream"/> and return a <see cref="T:System.Boolean"/>,
            while leaving <see cref="P:System.IO.Stream.Position"/> with the same
            (potentially non-0) value as it had before the function was called.
            
            This may change according to the TODO within
            <see cref="M:Metadata.MetadataFormat.Parse(System.IO.Stream)"/>, likely by
            adding a `HeaderLength` parameter to this attribute.
            </remarks>
            TODO: Add discussion of required signature according to exceptions in
            method Register(...)
        </member>
        <member name="T:Metadata.ITagFormat">
            <summary>
            Common properties to retrieve info from multiple tag formats.
            </summary>
        </member>
        <member name="P:Metadata.ITagFormat.Format">
            <summary>
            The display name of the tag format.
            </summary>
        </member>
        <member name="P:Metadata.ITagFormat.Fields">
            <summary>
            The low-level representations of the tag data.
            </summary>
        </member>
        <member name="P:Metadata.ITagFormat.Attributes">
            <summary>
            The proper standardized field redirects for the enclosing
            metadata format.
            </summary>
            
            <seealso cref="P:Metadata.ITagFormat.Fields"/>
        </member>
        <member name="T:Metadata.ITagAttributes">
            <summary>
            Common format-agnostic attributes mapping to different fields
            depending on how each is expressed in the particular format.
            </summary>
        </member>
        <member name="P:Metadata.ITagAttributes.Name">
            <summary>
            The display name of the enclosing file.
            </summary>
        </member>
        <member name="T:Metadata.ITagField">
            <summary>
            A single point of data saved in the tag.
            </summary>
        </member>
        <member name="P:Metadata.ITagField.SystemName">
            <summary>
            The byte header used to internally identify the field.
            </summary>
        </member>
        <member name="P:Metadata.ITagField.Name">
            <summary>
            The human-readable name of the field if available, or a
            representation of <see cref="P:Metadata.ITagField.SystemName"/> if not.
            </summary>
        </member>
        <member name="T:Metadata.TagFieldBase">
            <summary>
            A single point of data saved in the tag, with default helper implementations
            </summary>
        </member>
        <member name="P:Metadata.TagFieldBase.SystemName">
            <summary>
            The byte header used to internally identify the field.
            </summary>
        </member>
        <member name="P:Metadata.TagFieldBase.Name">
            <summary>
            The human-readable name of the field if available, or a
            representation of <see cref="P:Metadata.TagFieldBase.SystemName"/> if not.
            </summary>
            <remarks>
            The default implementation is to read the <see cref="P:Metadata.TagFieldBase.SystemName"/>
            as a UTF-8 encoded string enclosed in "{ " and " }"; if this is
            not suitable, the method should be overridden.
            </remarks>
        </member>
    </members>
</doc>
