<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Metadata</name>
    </assembly>
    <members>
        <member name="T:Metadata.FieldDictionary">
            <summary>
            An alias for <see cref="T:System.Collections.Generic.Dictionary`2"/> to ensure the
            proper equality of keys to <see cref="T:Metadata.TagField"/> objects.
            </summary>
        </member>
        <member name="T:Metadata.FieldDictionary.SequenceEqualityComparer`1">
            <summary>
            Test sequences for equality based on their values, not their
            object references.
            </summary>
            
            <remarks>
            Implementation from <see href="http://stackoverflow.com/a/7244729"/>.
            </remarks>
            
            <typeparam name="ElementType">
            The underlying type of the sequence.
            </typeparam>
        </member>
        <member name="F:Metadata.FieldDictionary.SequenceEqualityComparer`1.elementComparer">
            <summary>
            Provide a more robust meant of testing the equality of
            elements.
            </summary>
        </member>
        <member name="M:Metadata.FieldDictionary.SequenceEqualityComparer`1.Equals(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check two sequences for value equality.
            </summary>
            
            <returns>Whether the sequences are equal.</returns>
        </member>
        <member name="M:Metadata.FieldDictionary.SequenceEqualityComparer`1.GetHashCode(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Calculate a hash code based on the values of the sequence.
            </summary>
            
            <param name="obj">The sequence to hash.</param>
            
            <returns>The calculated hash.</returns>
        </member>
        <member name="F:Metadata.FieldDictionary.keyComparer">
            <summary>
            An instance of <see cref="T:Metadata.FieldDictionary.SequenceEqualityComparer`1"/>
            specialized to byte arrays.
            </summary>
        </member>
        <member name="M:Metadata.FieldDictionary.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Metadata.FieldDictionary"/>
            class that is empty and has the default initial capacity.
            </summary>
            
            <remarks>
            Every key in a <see cref="T:Metadata.FieldDictionary"/> must have a unique
            sequence of values.
            <para/>
            If you can estimate the size of the collection, using
            <see cref="M:Metadata.FieldDictionary.#ctor(System.Int32)"/> eliminates the need to perform
            a number of resizing operations while adding elements.
            <para/>
            This constructor is an O(1) operation.
            </remarks>
        </member>
        <member name="M:Metadata.FieldDictionary.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Metadata.FieldDictionary"/>
            class that is empty and has the specified initial capacity.
            </summary>
            
            <remarks>
            Every key in a <see cref="T:Metadata.FieldDictionary"/> must have a unique
            sequence of values.
            <para/>
            The capacity of a <see cref="T:Metadata.FieldDictionary"/> is the number of
            elements that can be added to the <see cref="T:Metadata.FieldDictionary"/>
            before resizing is necessary. As elements are added to a
            <see cref="T:Metadata.FieldDictionary"/>, the capacity is automatically
            increased as required by reallocating the internal array.
            Therefore, if the largest size of the collection can be estimated,
            specifying an initial capacity of that size or greater eliminates
            the need to perform a number of resizing operations while adding
            elements to the <see cref="T:Metadata.FieldDictionary"/>.
            <para/>
            This constructor is an O(1) operation.
            </remarks>
            
            <param name="capacity">
            The initial number of elements that the
            <see cref="T:Metadata.FieldDictionary"/> can contain.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="capacity"/> is less than 0.
            </exception>
        </member>
        <member name="M:Metadata.FieldDictionary.#ctor(Metadata.FieldDictionary)">
            <summary>
            Initializes a new instance of a <see cref="T:Metadata.FieldDictionary"/>
            that contains elements copied from <paramref name="dictionary"/>.
            </summary>
            
            <remarks>
            Every key in a <see cref="T:Metadata.FieldDictionary"/> must have a unique
            sequence of values; every key in <paramref name="dictionary"/>
            must therefore also have a unique sequence of values.
            <para/>
            IThe initial capacity of the new <see cref="T:Metadata.FieldDictionary"/> is
            large enough to contain all the elements in
            <paramref name="dictionary"/>.
            <para/>
            This constructor is an O(n) operation, where n is the number of
            elements in <paramref name="dictionary"/>.
            </remarks>
            
            <param name="dictionary">
            The <see cref="T:Metadata.FieldDictionary"/> whose elements are copied to the
            new <see cref="T:Metadata.FieldDictionary"/>.
            </param>
        </member>
        <member name="T:Metadata.IReadOnlyFieldDictionary">
            <summary>
            An alias for <see cref="T:System.Collections.Generic.Dictionary`2"/> to ensure the
            proper format for keys to <see cref="T:Metadata.TagField"/> objects.
            </summary>
        </member>
        <member name="T:Metadata.ScanAssemblyAttribute">
            <summary>
            Indicate that the assembly should be scanned for classes marked with
            <see cref="T:Metadata.MetadataFormatAttribute"/> to automatically register.
            
            This class cannot be inherited.
            </summary>
            
            <seealso cref="T:Metadata.MetadataFormatAttribute"/>
            <seealso cref="M:Metadata.MetadataFormat.Register(System.Reflection.Assembly)"/>
        </member>
        <member name="T:Metadata.MetadataFormatAttribute">
            <summary>
            Indicate that the class implements a metadata format specification.
            
            This class cannot be inherited.
            </summary>
            
            <remarks>
            The class must implement <see cref="T:Metadata.MetadataTag"/>.
            </remarks>
            
            <seealso cref="T:Metadata.ScanAssemblyAttribute"/>
            <seealso cref="M:Metadata.MetadataFormat.Register(System.String,System.Type)"/>
        </member>
        <member name="P:Metadata.MetadataFormatAttribute.Name">
            <summary>
            The unique short name representing this format.
            </summary>
        </member>
        <member name="M:Metadata.MetadataFormatAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Metadata.MetadataFormatAttribute"/> class with the specified
            <see cref="P:Metadata.MetadataFormatAttribute.Name"/>.
            </summary>
            
            <param name="name">
            The unique short name representing this format.
            <para/>
            It is recommended that this also be exposed as a constant on the
            type itself.
            </param>
        </member>
        <member name="T:Metadata.HeaderParserAttribute">
            <summary>
            Marks a method as being a validation function checking a binary header
            against that defined by the enclosing metadata specification.
            
            This class cannot be inherited.
            </summary>
            
            <remarks>
            If the passed byte[] is not a header of the proper format, the
            function should return `null`.
            </remarks>
            
            TODO: Add discussion of required signature according to exceptions in
            method Register(...)
            
            <seealso cref="M:Metadata.MetadataFormat.Register(System.String,System.UInt32,System.Reflection.MethodInfo)"/>
        </member>
        <member name="P:Metadata.HeaderParserAttribute.HeaderLength">
            <summary>
            The number of bytes this function processes to verify that the
            proper format header is present.
            </summary>
            
            <exception cref="T:System.ArgumentOutOfRangeException">
            New value for `set` is less than one.
            </exception>
        </member>
        <member name="M:Metadata.HeaderParserAttribute.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Metadata.HeaderParserAttribute"/> class with the
            specified <see cref="P:Metadata.HeaderParserAttribute.HeaderLength"/>.
            </summary>
            
            <param name="length">
            The number of bytes this function processes to verify that the
            proper format header is present.
            </param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">
            Value of <paramref name="length"/> is less than one.
            </exception>
        </member>
        <member name="T:Metadata.TagFieldAttribute">
            <summary>
            Marks a class as describing a field within a tag in a particular metadata
            format.
            </summary>
            
            <remarks>
            An exception will be thrown on registration if the class does not
            implement <see cref="T:Metadata.TagField"/>.
            </remarks>
        </member>
        <member name="F:Metadata.TagFieldAttribute.ISO88591">
            <summary>
            Reference to the ISO-8859-1 character encoding to allow passing
            byte headers as compile-time constant `string`s.
            </summary>
        </member>
        <member name="P:Metadata.TagFieldAttribute.Format">
            <summary>
            The short name associated with the metadata format, or `null` if
            it should be obtained from the enclosing type.
            </summary>
            
            <remarks>
            If this is `null` (the default), the immediately-enclosing type
            <em>must</em>  have a <see cref="T:Metadata.MetadataFormatAttribute"/> attribute,
            or an  exception will be thrown on the call to
            <see cref="M:Metadata.MetadataFormat.Register(System.String,System.Byte[],System.Type)"/>.
            </remarks>
            
            <seealso cref="P:Metadata.MetadataFormatAttribute.Name"/>
        </member>
        <member name="P:Metadata.TagFieldAttribute.Header">
            <summary>
            A sequence of bytes used to uniquely identify this type of field.
            </summary>
            
            <remarks>
            If multiple fields have the same structure and differ only in this
            identifier, the <see cref="T:Metadata.TagFieldAttribute"/> may be added to a
            common class once for each such tag.
            </remarks>
        </member>
        <member name="M:Metadata.TagFieldAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Metadata.TagFieldAttribute"/> class with the
            specified <see cref="P:Metadata.TagFieldAttribute.Header"/>.
            </summary>
            
            <remarks>
            <paramref name="header"/> is passed as a `string` rather than a
            `byte[]` as it needs to be assigned via a compile-time constant.
            </remarks>
            
            <param name="header">
            The unique byte header indicating this type of field,
            represented as an ISO-8859-1 string.
            </param>
        </member>
        <member name="T:Metadata.MetadataFormat">
            <summary>
            A data-free class providing a common means to work with multiple
            metadata formats.
            </summary>
        </member>
        <member name="F:Metadata.MetadataFormat.tagHeaderFunctions">
            <summary>
            Validation functions for each registered metadata format.
            </summary>
        </member>
        <member name="F:Metadata.MetadataFormat.tagFormats">
            <summary>
            The class encapsulating each registered metadata format.
            </summary>
        </member>
        <member name="F:Metadata.MetadataFormat.fieldKeyComparer">
            <summary>
            Maintain a single instance of the comparer rather than creating a new
            one for each dictionary.
            </summary>
            
            <seealso cref="F:Metadata.MetadataFormat.fieldTypes"/>
        </member>
        <member name="F:Metadata.MetadataFormat.fieldTypes">
            <summary>
            Store lookup tables for the fields of each of the registered
            metadata formats.
            </summary>
        </member>
        <member name="F:Metadata.MetadataFormat.assemblies">
            <summary>
            A registry of previously-scanned assemblies in order to prevent
            unnecessary use of reflection methods.
            </summary>
        </member>
        <member name="M:Metadata.MetadataFormat.#cctor">
            <summary>
            Automatically add any 
            </summary>
            
            <seealso cref="M:Metadata.MetadataFormat.RefreshFormats``1"/>
        </member>
        <member name="M:Metadata.MetadataFormat.RefreshFormats``1">
            <summary>
            Scan the aseembly enclosing the specified for implementations of
            metadata formats.
            </summary>
            
            <remarks>
            The explicit type parameter is preferred over scanning loaded assemblies
            as oftentimes this will be the first time the 
            </remarks>
            
            <typeparam name="T">
            A type from the assembly to scan, extending <see cref="T:Metadata.MetadataTag"/>.
            </typeparam>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.Reflection.Assembly)">
            <summary>
            Scan the given assembly for all types marked as implementing a
            metadata format in a suitable manner for automatic lookup.
            <para/>
            Subsequent calls on a previously-scanned assembly will be ignored
            in order to save unnecessary type reflection.
            </summary>
            
            <param name="assembly">The assembly to scan.</param>
            
            <seealso cref="T:Metadata.MetadataFormatAttribute"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.Type)">
            <summary>
            Add the given metadata format type to the lookup tables according
            to the  descriptor specified in its
            <see cref="P:Metadata.MetadataFormatAttribute.Name"/>.
            </summary>
            
            <remarks>
            Note that if multiple types are registered under the same name,
            any later registrations will override the previous.
            </remarks>
            
            <param name="format">The type to add.</param>
            
            <seealso cref="T:Metadata.HeaderParserAttribute"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.String,System.Type)">
            <summary>
            Add the given metadata format type to the lookup tables under the
            specified custom descriptor, even if it does not have any
            associated <see cref="T:Metadata.MetadataFormatAttribute"/>.
            </summary>
            
            <remarks>
            The validation function must still be identified with a
            <see cref="T:Metadata.HeaderParserAttribute"/>.
            <para/>
            Note that if multiple types are registered under the same name,
            any later registrations will override the previous.
            </remarks>
            
            <param name="name">
            A short name for the format to be used as an access key for later
            lookups.
            <para/>
            It is recommended that this also be exposed as a constant.
            </param>
            <param name="format">The type to add.</param>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.String,System.Byte[],System.Type)">
            <summary>
            Add the given tag field type to the lookup tables under the proper
            format specifier.
            </summary>
            
            <param name="format">
            The short name of the format defining this field, or `null` to
            autodetect from the enclosing class.
            </param>
            <param name="header">
            The unique specifier of this field.
            </param>
            <param name="fieldType">
            The <see cref="T:System.Type"/> implementing the field.
            </param>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.String,System.UInt32,System.Reflection.MethodInfo)">
            <summary>
            Add the given method to the lookup tables under the specified
            custom descriptor.
            <para/>
            This should almost purely be called via
            <see cref="M:Metadata.MetadataFormat.Register(System.String,System.Type)"/>, and has been separated
            primarily for code clarity.
            </summary>
            
            <remarks>
            Note that if multiple methods are registered under the same name,
            any later registrations will override the previous.
            </remarks>
            
            <param name="name">
            A short name for the format to be used as an access key for later
            lookups.
            </param>
            <param name="headerLength">
            The number of bytes <paramref name="method"/> uses to read the tag
            header.
            </param>
            <param name="method">The method to add.</param>
        </member>
        <member name="M:Metadata.MetadataFormat.Parse(System.IO.Stream)">
            <summary>
            Check the stream against all registered tag formats, and return
            those that match the header.
            </summary>
            
            <remarks>
            While, in theory, only a single header should match, the class
            structure is such that this is not a restriction; supporting this
            feature allows for nonstandard usages without exclusive headers.
            
            The callee is left to determine the best means of handling the
            case of Detect(...).Count > 1.
            </remarks>
            
            <param name="stream">The bytestream to test.</param>
            
            <returns>The keys of all matching formats.</returns>
        </member>
        <member name="T:Metadata.MetadataTag">
            <summary>
            Common properties to retrieve info from multiple tag formats.
            </summary>
        </member>
        <member name="P:Metadata.MetadataTag.Format">
            <summary>
            The display name of the tag format.
            </summary>
        </member>
        <member name="P:Metadata.MetadataTag.Length">
            <summary>
            The length in bytes of the tag, not including the header.
            </summary>
            
            <remarks>
            The underlying value should be set in any function marked with
            <see cref="T:Metadata.HeaderParserAttribute"/>; if that function
            sets it to 0, the incoming stream will be read according to
            </remarks>
        </member>
        <member name="P:Metadata.MetadataTag.Fields">
            <summary>
            The low-level representations of the tag data.
            </summary>
        </member>
        <member name="P:Metadata.MetadataTag.Attributes">
            <summary>
            The proper standardized field redirects for the enclosing
            metadata format.
            </summary>
            
            <seealso cref="P:Metadata.MetadataTag.Fields"/>
        </member>
        <member name="M:Metadata.MetadataTag.Parse(System.IO.BinaryReader)">
            <summary>
            Parse a tag of unknown length until some end-of-tag marker is
            reached.
            </summary>
            
            <param name="stream">The stream to read.</param>
        </member>
        <member name="M:Metadata.MetadataTag.ParseAsync(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Parse a tag of known length asynchronously.
            </summary>
            
            <remarks>
            The default implementation simply redirects the data to
            <see cref="M:Metadata.MetadataTag.Parse(System.IO.BinaryReader)"/> within a <see cref="T:System.Threading.Tasks.Task"/>.
            </remarks>
            
            <param name="data">The sequence of bytes to parse.</param>
        </member>
        <member name="T:Metadata.ITagAttributes">
            <summary>
            Common format-agnostic attributes mapping to different fields
            depending on how each is expressed in the particular format.
            </summary>
        </member>
        <member name="P:Metadata.ITagAttributes.Name">
            <summary>
            The display names of the enclosing file.
            </summary>
        </member>
        <member name="T:Metadata.TagField">
            <summary>
            A single point of data saved in the tag, with default helper
            implementations.
            </summary>
        </member>
        <member name="P:Metadata.TagField.SystemName">
            <summary>
            The byte header used to internally identify the field.
            </summary>
        </member>
        <member name="P:Metadata.TagField.Length">
            <summary>
            The length in bytes of the data contained in the field (excluding
            the header).
            </summary>
        </member>
        <member name="P:Metadata.TagField.Name">
            <summary>
            The human-readable name of the field if available, or a
            representation of <see cref="P:Metadata.TagField.SystemName"/> if not.
            </summary>
            
            <remarks>
            The default implementation is to read the <see cref="P:Metadata.TagField.SystemName"/>
            as a UTF-8 encoded string enclosed in "{ " and " }"; if this is
            not suitable, the method should be overridden.
            </remarks>
        </member>
        <member name="P:Metadata.TagField.Values">
            <summary>
            All values contained within this field.
            </summary>
        </member>
        <member name="M:Metadata.TagField.Parse(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Read a sequence of bytes in the manner appropriate to the specific
            type of field.
            </summary>
            
            <param name="data">The data to read.</param>
        </member>
    </members>
</doc>
