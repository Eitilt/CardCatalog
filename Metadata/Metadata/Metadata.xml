<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Metadata</name>
    </assembly>
    <members>
        <member name="T:Metadata.FieldDictionary">
            <summary>
            An alias for <see cref="T:System.Collections.Generic.Dictionary`2"/> to ensure the
            proper equality of keys to <see cref="T:Metadata.TagField"/> objects.
            </summary>
        </member>
        <member name="F:Metadata.FieldDictionary.keyComparer">
            <summary>
            An instance of <see cref="T:Metadata.Helpers.SequenceEqualityComparer`1"/>
            specialized to byte arrays.
            </summary>
        </member>
        <member name="P:Metadata.FieldDictionary.KeyComparer">
            <summary>
            Provide access to a comparer specialized for field keys.
            </summary>
        </member>
        <member name="M:Metadata.FieldDictionary.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Metadata.FieldDictionary"/>
            class that is empty and has the default initial capacity.
            </summary>
            
            <remarks>
            Every key in a <see cref="T:Metadata.FieldDictionary"/> must have a unique
            sequence of values.
            <para/>
            If you can estimate the size of the collection, using
            <see cref="M:Metadata.FieldDictionary.#ctor(System.Int32)"/> eliminates the need to perform
            a number of resizing operations while adding elements.
            <para/>
            This constructor is an O(1) operation.
            </remarks>
        </member>
        <member name="M:Metadata.FieldDictionary.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Metadata.FieldDictionary"/>
            class that is empty and has the specified initial capacity.
            </summary>
            
            <remarks>
            Every key in a <see cref="T:Metadata.FieldDictionary"/> must have a unique
            sequence of values.
            <para/>
            The capacity of a <see cref="T:Metadata.FieldDictionary"/> is the number of
            elements that can be added to the <see cref="T:Metadata.FieldDictionary"/>
            before resizing is necessary. As elements are added to a
            <see cref="T:Metadata.FieldDictionary"/>, the capacity is automatically
            increased as required by reallocating the internal array.
            Therefore, if the largest size of the collection can be estimated,
            specifying an initial capacity of that size or greater eliminates
            the need to perform a number of resizing operations while adding
            elements to the <see cref="T:Metadata.FieldDictionary"/>.
            <para/>
            This constructor is an O(1) operation.
            </remarks>
            
            <param name="capacity">
            The initial number of elements that the
            <see cref="T:Metadata.FieldDictionary"/> can contain.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="capacity"/> is less than 0.
            </exception>
        </member>
        <member name="M:Metadata.FieldDictionary.#ctor(System.Collections.Generic.Dictionary{System.Byte[],System.Collections.Generic.IEnumerable{Metadata.TagField}})">
            <summary>
            Initializes a new instance of a <see cref="T:Metadata.FieldDictionary"/>
            that contains elements copied from <paramref name="dictionary"/>.
            </summary>
            
            <remarks>
            Every key in a <see cref="T:Metadata.FieldDictionary"/> must have a unique
            sequence of values; every key in <paramref name="dictionary"/>
            must therefore also have a unique sequence of values.
            <para/>
            IThe initial capacity of the new <see cref="T:Metadata.FieldDictionary"/> is
            large enough to contain all the elements in
            <paramref name="dictionary"/>.
            <para/>
            This constructor is an O(n) operation, where n is the number of
            elements in <paramref name="dictionary"/>.
            </remarks>
            
            <param name="dictionary">
            The <see cref="T:Metadata.FieldDictionary"/> whose elements are copied to the
            new <see cref="T:Metadata.FieldDictionary"/>.
            </param>
        </member>
        <member name="T:Metadata.IReadOnlyFieldDictionary">
            <summary>
            An alias for <see cref="T:System.Collections.Generic.Dictionary`2"/> to ensure the
            proper format for keys to <see cref="T:Metadata.TagField"/> objects.
            </summary>
        </member>
        <member name="T:Metadata.Helpers">
            <summary>
            Miscellaneous helper functions and classes.
            </summary>
        </member>
        <member name="M:Metadata.Helpers.GetOrCreate``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            Retrieve the requested value from the dictionary, creating a new
            entry if necessary.
            </summary>
            
            <typeparam name="TKey">
            The type used for the dictionary's keys.
            </typeparam>
            <typeparam name="TValue">
            The type used for the dictionary's values.
            </typeparam>
            
            <param name="dictionary">
            The <see cref="T:System.Collections.Generic.Dictionary`2"/> on which to operate.
            </param>
            <param name="key">The dictionary key to access.</param>
            
            <returns>
            The object located at <paramref name="key"/> in
            <paramref name="dictionary"/>.
            </returns>
        </member>
        <member name="T:Metadata.Helpers.SequenceEqualityComparer`1">
            <summary>
            Test sequences for equality based on their values, not their
            object references.
            </summary>
            
            <remarks>
            Implementation from <see href="http://stackoverflow.com/a/7244729"/>.
            </remarks>
            
            <typeparam name="ElementType">
            The underlying type of the sequence.
            </typeparam>
        </member>
        <member name="F:Metadata.Helpers.SequenceEqualityComparer`1.elementComparer">
            <summary>
            Provide a more robust meant of testing the equality of
            elements.
            </summary>
        </member>
        <member name="M:Metadata.Helpers.SequenceEqualityComparer`1.Equals(`0[],`0[])">
            <summary>
            Check two sequences for value equality.
            </summary>
            
            <returns>Whether the sequences are equal.</returns>
        </member>
        <member name="M:Metadata.Helpers.SequenceEqualityComparer`1.GetHashCode(`0[])">
            <summary>
            Calculate a hash code based on the values of the sequence.
            </summary>
            
            <param name="obj">The sequence to hash.</param>
            
            <returns>The calculated hash.</returns>
        </member>
        <member name="M:Metadata.Helpers.ReadAll(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream until it ends or the requested number of
            bytes has been reached.
            </summary>
            
            <param name="stream">
            The <see cref="T:System.IO.Stream"/> on which to operate.
            </param>
            <param name="buffer">
            The destination in which to save the read bytes.
            </param>
            <param name="offset">
            The index in <paramref name="buffer"/> of the first read byte.
            </param>
            <param name="count">The number of bytes to read.</param>
            
            <returns>
            The number of bytes that were successfully read. This may be less
            than <paramref name="count"/> if the stream ended before that
            number of bytes was reached.
            </returns>
        </member>
        <member name="T:Metadata.ScanAssemblyAttribute">
            <summary>
            Indicate that the assembly should be scanned for classes marked with
            <see cref="T:Metadata.MetadataFormatAttribute"/> to automatically register.
            
            This class cannot be inherited.
            </summary>
            
            <seealso cref="T:Metadata.MetadataFormatAttribute"/>
            <seealso cref="M:Metadata.MetadataFormat.Register(System.Reflection.Assembly)"/>
        </member>
        <member name="T:Metadata.MetadataFormatAttribute">
            <summary>
            Indicate that the class implements a metadata format specification.
            
            This class cannot be inherited.
            </summary>
            
            <remarks>
            The class must implement <see cref="T:Metadata.MetadataTag"/>.
            </remarks>
            
            <seealso cref="T:Metadata.ScanAssemblyAttribute"/>
            <seealso cref="M:Metadata.MetadataFormat.Register``1(System.String)"/>
        </member>
        <member name="P:Metadata.MetadataFormatAttribute.Name">
            <summary>
            The unique short name representing this format.
            </summary>
        </member>
        <member name="M:Metadata.MetadataFormatAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Metadata.MetadataFormatAttribute"/> class with the specified
            <see cref="P:Metadata.MetadataFormatAttribute.Name"/>.
            </summary>
            
            <param name="name">
            The unique short name representing this format.
            <para/>
            It is recommended that this also be exposed as a constant on the
            type itself.
            </param>
        </member>
        <member name="T:Metadata.HeaderParserAttribute">
            <summary>
            Marks a method as being a validation function checking a binary header
            against that defined by the enclosing metadata specification.
            
            This class cannot be inherited.
            </summary>
            
            <remarks>
            If the passed byte[] is not a header of the proper format, the
            function should return `null`.
            </remarks>
            
            TODO: Add discussion of required signature according to exceptions in
            method Register(...)
            
            <seealso cref="M:Metadata.MetadataFormat.Register(System.String,System.UInt32,System.Reflection.MethodInfo)"/>
        </member>
        <member name="P:Metadata.HeaderParserAttribute.HeaderLength">
            <summary>
            The number of bytes this function processes to verify that the
            proper format header is present.
            </summary>
            
            <exception cref="T:System.ArgumentOutOfRangeException">
            New value for `set` is less than one.
            </exception>
        </member>
        <member name="M:Metadata.HeaderParserAttribute.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Metadata.HeaderParserAttribute"/> class with the specified
            <see cref="P:Metadata.HeaderParserAttribute.HeaderLength"/>.
            </summary>
            
            <param name="length">
            The number of bytes this function processes to verify that the
            proper format header is present.
            </param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">
            Value of <paramref name="length"/> is less than one.
            </exception>
        </member>
        <member name="T:Metadata.TagFieldAttribute">
            <summary>
            Marks a class as describing a field within a tag in a particular
            metadata format.
            </summary>
            
            <remarks>
            An exception will be thrown on registration if the class does not
            implement <see cref="T:Metadata.TagField"/>.
            </remarks>
        </member>
        <member name="F:Metadata.TagFieldAttribute.ISO88591">
            <summary>
            Reference to the ISO-8859-1 character encoding to allow passing
            byte headers as compile-time constant `string`s.
            </summary>
        </member>
        <member name="P:Metadata.TagFieldAttribute.Format">
            <summary>
            The short name associated with the metadata format, or `null` if
            it should be obtained from the enclosing type.
            </summary>
            
            <remarks>
            If this is `null` (the default), the immediately-enclosing type
            <em>must</em>  have a <see cref="T:Metadata.MetadataFormatAttribute"/>
            attribute, or an exception will be thrown on the call to
            <see cref="M:Metadata.MetadataFormat.Register``1(System.String,System.Byte[])"/>.
            </remarks>
            
            <seealso cref="P:Metadata.MetadataFormatAttribute.Name"/>
        </member>
        <member name="P:Metadata.TagFieldAttribute.Header">
            <summary>
            A sequence of bytes used to uniquely identify this type of field.
            </summary>
            
            <remarks>
            If multiple fields have the same structure and differ only in this
            identifier, the <see cref="T:Metadata.TagFieldAttribute"/> may be added to a
            common class once for each such tag.
            </remarks>
        </member>
        <member name="M:Metadata.TagFieldAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Metadata.TagFieldAttribute"/>
            class with headers as given by any members decorated with a
            <see cref="T:Metadata.FieldNamesAttribute"/>.
            </summary>
        </member>
        <member name="M:Metadata.TagFieldAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Metadata.TagFieldAttribute"/>
            class with the specified <see cref="P:Metadata.TagFieldAttribute.Header"/>.
            </summary>
            
            <remarks>
            <paramref name="header"/> is passed as a `string` rather than a
            `byte[]` as it needs to be assigned via a compile-time constant.
            </remarks>
            
            <param name="header">
            The unique byte header indicating this type of field, represented
            as an ISO-8859-1 string.
            </param>
        </member>
        <member name="T:Metadata.FieldNamesAttribute">
            <summary>
            Marks a method as returning a list of the headers to which the
            enclosing class applies, or a parameter/property as being such a
            predefined list.
            </summary>
            
            <remarks>
            The field will not be registered under the returned under the returned
            headers unless the class has a <see cref="T:Metadata.TagFieldAttribute"/> without
            any string parameter.
            <para />
            If on a method: an exception will be thrown on class registration if
            it cannot be called without parameters or if it doesn't return an
            <see cref="T:IEnumerable{byte[]}"/>; if on a parameter or property, it
            simply needs to be of that type. In both cases, the member must be
            `static` and `public`.
            </remarks>
        </member>
        <member name="T:Metadata.MetadataFormat">
            <summary>
            A data-free class providing a common means to work with multiple
            metadata formats.
            </summary>
        </member>
        <member name="F:Metadata.MetadataFormat.tagFormats">
            <summary>
            The class encapsulating each registered metadata format.
            </summary>
        </member>
        <member name="M:Metadata.MetadataFormat.FieldTypes(System.String)">
            <summary>
            Get all field types registered for the given metadata format.
            </summary>
            
            <param name="format">The short name of the desired format.</param>
            
            <returns>
            The classes implementing each <see cref="T:Metadata.TagField"/>.
            </returns>
        </member>
        <member name="F:Metadata.MetadataFormat.assemblies">
            <summary>
            A registry of previously-scanned assemblies in order to prevent
            unnecessary use of reflection methods.
            </summary>
        </member>
        <member name="M:Metadata.MetadataFormat.#cctor">
            <summary>
            Automatically add any metadata classes in opened assemblies on
            first call to the class.
            </summary>
            
            <seealso cref="M:Metadata.MetadataFormat.RefreshFormats``1"/>
        </member>
        <member name="M:Metadata.MetadataFormat.RefreshFormats``1">
            <summary>
            Scan the assembly enclosing the specified for implementations of
            metadata formats.
            </summary>
            
            <remarks>
            The explicit type parameter is preferred over scanning loaded assemblies
            as oftentimes this will be the first time the 
            </remarks>
            
            <typeparam name="T">
            Any type from the assembly to scan.
            </typeparam>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.Reflection.Assembly)">
            <summary>
            Scan the given assembly for all types marked as implementing a
            metadata format in a suitable manner for automatic lookup.
            <para/>
            Subsequent calls on a previously-scanned assembly will be ignored
            in order to save unnecessary type reflection.
            </summary>
            
            <param name="assembly">The assembly to scan.</param>
            
            <seealso cref="T:Metadata.MetadataFormatAttribute"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Register``1">
            <summary>
            Add the given metadata format type to the lookup tables according
            to the  descriptor specified in its
            <see cref="P:Metadata.MetadataFormatAttribute.Name"/>.
            </summary>
            
            <remarks>
            Note that if multiple types are registered under the same name,
            any later registrations will override the previous.
            </remarks>
            
            <typeparam name="T">
            The <see cref="T:Metadata.MetadataTag"/> class implementing the format.
            </typeparam>
            
            <seealso cref="T:Metadata.HeaderParserAttribute"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Register``1(System.String)">
            <summary>
            Add the given metadata format type to the lookup tables under the
            specified custom descriptor, even if it does not have any
            associated <see cref="T:Metadata.MetadataFormatAttribute"/>.
            </summary>
            
            <remarks>
            The validation function must still be identified with a
            <see cref="T:Metadata.HeaderParserAttribute"/>.
            <para/>
            Note that if multiple types are registered under the same name,
            any later registrations will override the previous.
            </remarks>
            
            <typeparam name="T">
            The <see cref="T:Metadata.MetadataTag"/> class implementing the format.
            </typeparam>
            
            <param name="format">
            A short name for the format to be used as an access key for later
            lookups.
            <para/>
            It is recommended that this also be exposed as a constant.
            </param>
        </member>
        <member name="M:Metadata.MetadataFormat.Register``1(System.String,System.Byte[])">
            <summary>
            Add the given tag field type to the lookup tables under the proper
            format specifier.
            </summary>
            
            <typeparam name="T">
            The <see cref="T:Metadata.TagField"/> class implementing the field.
            </typeparam>
            
            <param name="format">
            The short name of the format defining this field, or `null` to
            autodetect from the enclosing class.
            </param>
            <param name="header">
            The unique specifier of this field.
            </param>
        </member>
        <member name="M:Metadata.MetadataFormat.Register``1(System.String,System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Add the given tag field type to the lookup tables under the proper
            format specifier.
            </summary>
            
            <typeparam name="T">
            The <see cref="T:Metadata.TagField"/> class implementing the field.
            </typeparam>
            
            <param name="format">
            The short name of the format defining this field, or `null` to
            autodetect from the enclosing class.
            </param>
            <param name="headerList">
            The unique specifiers of this field.
            </param>
        </member>
        <member name="M:Metadata.MetadataFormat.MethodSanityChecks``1(System.Reflection.MethodInfo)">
            <summary>
            Group the restriction checking of validation functions for easy
            reuse.
            </summary>
            
            <typeparam name="T">
            The required return type of <paramref name="method"/>.
            </typeparam>
            
            <param name="method">The validation function to check.</param>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.String,System.UInt32,System.Reflection.MethodInfo)">
            <summary>
            Add the given format initialization method to the lookup tables
            under the specified custom descriptor.
            </summary>
            
            <remarks>
            This should almost purely be called via
            <see cref="M:Metadata.MetadataFormat.Register``1(System.String)"/>, and has been separated
            primarily for code clarity.
            </remarks>
            
            <param name="format">
            A short name for the format to be used as an access key for later
            lookups.
            </param>
            <param name="headerLength">
            The number of bytes <paramref name="method"/> uses to read the tag
            header.
            </param>
            <param name="method">The method to add.</param>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.String,System.Byte[],System.UInt32,System.Reflection.MethodInfo)">
            <summary>
            Add the given field initialization method to the lookup tables
            under the specified custom descriptor.
            </summary>
            
            <remarks>
            Note that if multiple methods are registered under the same
            <paramref name="format"/> and <paramref name="field"/> pairing,
            any later registrations will override the previous.
            <para/>
            This should almost purely be called via
            <see cref="M:Metadata.MetadataFormat.Register``1(System.String)"/>, and has been separated
            primarily for code clarity.
            </remarks>
            
            <param name="format">
            A short name for the format to be used as an access key for later
            lookups.
            </param>
            <param name="field">
            The unique identifier for the associated field.
            </param>
            <param name="headerLength">
            The number of bytes <paramref name="method"/> uses to read the tag
            header.
            </param>
            <param name="method">The method to add.</param>
        </member>
        <member name="M:Metadata.MetadataFormat.ParseAsync(System.IO.Stream)">
            <summary>
            Parse all recognized tags in a stream asynchronously.
            </summary>
            
            <param name="stream">The stream to parse.</param>
            
            <returns>The resulting <see cref="T:Metadata.MetadataTag"/>s.</returns>
        </member>
        <member name="T:Metadata.MetadataTag">
            <summary>
            Common properties to retrieve info from multiple tag formats.
            </summary>
        </member>
        <member name="P:Metadata.MetadataTag.Format">
            <summary>
            The display name of the tag format.
            </summary>
        </member>
        <member name="P:Metadata.MetadataTag.Length">
            <summary>
            The length in bytes of the tag, not including the header.
            </summary>
            
            <remarks>
            The underlying value should be set in any function marked with
            <see cref="T:Metadata.HeaderParserAttribute"/>; if that function
            sets it to 0, the incoming stream will be read according to
            </remarks>
        </member>
        <member name="P:Metadata.MetadataTag.FieldBase">
            <summary>
            An editable redirect for the low-level data.
            </summary>
            
            <seealso cref="P:Metadata.MetadataTag.Fields"/>
        </member>
        <member name="P:Metadata.MetadataTag.Fields">
            <summary>
            The low-level representations of the tag data.
            </summary>
        </member>
        <member name="P:Metadata.MetadataTag.Attributes">
            <summary>
            The proper standardized field redirects for the enclosing
            metadata format.
            </summary>
            
            <seealso cref="P:Metadata.MetadataTag.Fields"/>
        </member>
        <member name="M:Metadata.MetadataTag.Parse(System.IO.Stream)">
            <summary>
            Parse the fields contained within a tag.
            </summary>
            
            <remarks>
            TODO: Handle tags with unknown length.
            </remarks>
            
            <param name="stream">The stream to read.</param>
        </member>
        <member name="M:Metadata.ReflectionData`1.ParseAsync(System.IO.Stream,System.Collections.Generic.IEnumerable{Metadata.ReflectionData{`0}})">
            <summary>
            Check the stream against all registered <see cref="T:Metadata.IParsable"/>
            formats, and return the sequence the occur in within the file.
            </summary>
            
            <remarks>
            It is expected that no more than a single validation function will
            match any given sequence of bytes. If this is not the case, only
            the first-matched will be generated.
            <para/>
            TODO: It may be best to return an object explicitly combining
            all recognized tags <em>along with</em> unknown data.
            </remarks>
            
            <param name="stream">The bytestream to parse.</param>
            <param name="types">
            The types that might be contained in the stream.
            </param>
            
            <returns>The generated objects.</returns>
        </member>
        <member name="T:Metadata.ITagAttributes">
            <summary>
            Common format-agnostic attributes mapping to different fields
            depending on how each is expressed in the particular format.
            </summary>
        </member>
        <member name="P:Metadata.ITagAttributes.Name">
            <summary>
            The display names of the enclosing file.
            </summary>
        </member>
        <member name="T:Metadata.TagField">
            <summary>
            A single point of data saved in the tag, with default helper
            implementations.
            </summary>
        </member>
        <member name="T:Metadata.TagField.Empty">
            <summary>
            A default implementation of <see cref="T:Metadata.TagField"/>, not providing
            any data formatting.
            </summary>
        </member>
        <member name="M:Metadata.TagField.Empty.#ctor(System.Byte[],System.Int32)">
            <summary>
            The minimal constructor for creating a skeleton instance.
            </summary>
            
            <param name="name">
            The value to save to <see cref="P:Metadata.TagField.Empty.SystemName"/>.
            </param>
            <param name="length">
            The value to save to <see cref="P:Metadata.TagField.Length"/>.
            </param>
        </member>
        <member name="F:Metadata.TagField.Empty.name">
            <summary>
            Underlying field ID to work around the lack of a
            <see cref="P:Metadata.TagField.Empty.SystemName"/>.set.
            </summary>
        </member>
        <member name="P:Metadata.TagField.Empty.SystemName">
            <summary>
            The byte header used to internally identify the field.
            </summary>
        </member>
        <member name="F:Metadata.TagField.Empty.data">
            <summary>
            The container to hold the raw data of this field.
            </summary>
        </member>
        <member name="P:Metadata.TagField.Empty.Values">
            <summary>
            All data contained by this field, in a human-readable format.
            </summary>
        </member>
        <member name="M:Metadata.TagField.Empty.Parse(System.IO.Stream)">
            <summary>
            Read a sequence of bytes in the manner appropriate to the
            specific type of field.
            </summary>
            
            <param name="stream">The data to read.</param>
        </member>
        <member name="P:Metadata.TagField.SystemName">
            <summary>
            The byte header used to internally identify the field.
            </summary>
        </member>
        <member name="P:Metadata.TagField.Length">
            <summary>
            The length in bytes of the data contained in the field (excluding
            the header).
            </summary>
        </member>
        <member name="P:Metadata.TagField.Name">
            <summary>
            The human-readable name of the field if available, or a
            representation of <see cref="P:Metadata.TagField.SystemName"/> if not.
            </summary>
            
            <remarks>
            The default implementation is to read the <see cref="P:Metadata.TagField.SystemName"/>
            as a UTF-8 encoded string enclosed in "{ " and " }"; if this is
            not suitable, the method should be overridden.
            </remarks>
        </member>
        <member name="P:Metadata.TagField.Subtitle">
            <summary>
            Extra human-readable information describing the field, such as the
            "category" of a header with multiple realizations.
            </summary>
            
            <remarks>
            The default implementation is to return `null`; if this is not
            suitable, the method should be overridden.
            </remarks>
        </member>
        <member name="P:Metadata.TagField.Values">
            <summary>
            All data contained by this field, in a human-readable format.
            </summary>
        </member>
        <member name="M:Metadata.TagField.Parse(System.IO.Stream)">
            <summary>
            Read a sequence of bytes in the manner appropriate to the specific
            type of field.
            </summary>
            
            <param name="stream">The data to read.</param>
        </member>
    </members>
</doc>
