<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Metadata</name>
    </assembly>
    <members>
        <member name="T:Metadata.ConcatStream">
            <summary>
            Join multiple streams into a single continuous object.
            </summary>
        </member>
        <member name="F:Metadata.ConcatStream.streams">
            <summary>
            The underlying individual streams, before concatenation.
            </summary>
        </member>
        <member name="F:Metadata.ConcatStream.index">
            <summary>
            The index of the currently active individual <see cref="T:System.IO.Stream"/>
            within <see cref="F:Metadata.ConcatStream.streams"/>.
            </summary>
        </member>
        <member name="M:Metadata.ConcatStream.IncrementIndex">
            <summary>
            Progress to the next concatenated stream, seeking to its beginning
            if possible.
            </summary>
            
            <returns>
            `false` there is no available next stream, `true` otherwise.
            </returns>
        </member>
        <member name="P:Metadata.ConcatStream.CanRead">
            <summary>
            Whether all concatenated streams (and therefore this wrapper)
            support reading.
            </summary>
            
            <remarks>
            If any concatenated stream is closed, this property returns false.
            </remarks>
        </member>
        <member name="P:Metadata.ConcatStream.CanSeek">
            <summary>
            Whether all concatenated streams (and therefore this wrapper)
            support seeking.
            </summary>
            
            <remarks>
            If any concatenated stream is closed, this property returns false.
            </remarks>
        </member>
        <member name="P:Metadata.ConcatStream.CanTimeout">
            <summary>
            Whether any concatenated stream (and therefore this wrapper)
            may time out.
            </summary>
        </member>
        <member name="P:Metadata.ConcatStream.CanWrite">
            <summary>
            Whether all concatenated streams (and therefore this wrapper)
            support writing.
            </summary>
            
            <remarks>
            If any concatenated stream is closed, this property returns false.
            </remarks>
        </member>
        <member name="P:Metadata.ConcatStream.Length">
            <summary>
            The length in bytes of the combined stream.
            </summary>
            
            <exception cref="T:System.NotSupportedException">
            At least one concatenated <see cref="T:System.IO.Stream"/> does not support
            seeking.
            </exception>
        </member>
        <member name="P:Metadata.ConcatStream.Position">
            <summary>
            Gets or sets the position of the concatenated stream.
            </summary>
            
            <exception cref="T:System.IndexOutOfRangeException">
            All concatenated streams must support seeking to get or set the
            position. Use the <see cref="P:Metadata.ConcatStream.CanSeek"/> property to determine
            whether the stream supports seeking.
            <para/>
            Unlike other <see cref="T:System.IO.Stream"/> implementations, seeking to any
            location beyond the length of the stream is <em>not</em> supported.
            
            TODO: See about bringing that into compliance.
            <para />
            The Position property does not keep track of the number of bytes
            from the stream that have been consumed, skipped, or both.
            </exception>
            
            <seealso cref="M:Metadata.ConcatStream.Seek(System.Int64,System.IO.SeekOrigin)"/>
        </member>
        <member name="M:Metadata.ConcatStream.Flush">
            <summary>
            Clears all buffers for the concatenated streams and causes any
            buffered data to be written to the underlying device.
            </summary>
            
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            
            <seealso cref="M:Metadata.ConcatStream.FlushAsync(System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Metadata.ConcatStream.FlushAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously clears all buffers for the concatenated streams and
            causes any buffered data to be written to the underlying device.
            </summary>
            
            <param name="cancellationToken">The token to monitor for
            cancellation requests. The default value is
            <see cref="P:System.Threading.CancellationToken.None"/>.
            </param>
            
            <returns>
            A task that represents the asynchronous flush operation.
            </returns>
            
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            
            <seealso cref="M:Metadata.ConcatStream.Flush"/>
        </member>
        <member name="M:Metadata.ConcatStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the current stream and advances the
            position within the stream by the number of bytes read.
            </summary>
            
            <remarks>
            Use the <see cref="P:Metadata.ConcatStream.CanRead"/> property to determine whether the
            current instance supports reading. Use the <see cref="M:Metadata.ConcatStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/>
            method to read asynchronously from the current stream.
            <para/>
            If streams concatenated before <see cref="P:Metadata.ConcatStream.Position"/> have more
            elements added to them, the output remains unaffected until and
            unless <see cref="P:Metadata.ConcatStream.Position"/> is seeked to before those new
            elements.
            <para/>
            The current position within the stream is advanced by the number
            of bytes read; however, if an exception occurs, the current
            position within the stream remains unchanged. The call will block
            until at least one byte of data can be read, in the event that no
            data is available -- it returns 0 only when there is no more data
            in the stream and no more is expected (such as a closed socket or
            end of file). Fewer bytes than requested may be returned even if
            the end of the stream has not been reached.
            
            TODO: Ensure that the rewind-on-exception occurs properly.
            </remarks>
            
            <param name="buffer">
            When this method returns, the buffer contains the specified byte
            array with the values between offset and (offset + count - 1)
            replaced by the bytes read from the current source.
            </param>
            <param name="offset">
            The zero-based byte offset in buffer at which to begin storing the
            data read from the current stream.
            </param>
            <param name="count">
            The maximum number of bytes to be read from the current stream.
            </param>
            
            <returns>
            The total number of bytes read into the buffer. This can be less
            than the number of bytes requested if that many bytes are not
            currently available, or zero (0) if the end of the stream has been
            reached.
            </returns>
            
            <exception cref="T:System.ArgumentException">
            The sum of offset and count is larger than the buffer length.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="buffer"/> is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="offset"/> or <paramref name="count"/> is negative.
            </exception>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support reading.
            </exception>
            
            <seealso cref="M:Metadata.ConcatStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/>
            <seealso cref="M:Metadata.ConcatStream.ReadByte"/>
        </member>
        <member name="M:Metadata.ConcatStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously reads a sequence of bytes from the current stream
            and advances the position within the stream by the number of bytes
            read.
            </summary>
            
            <remarks>
            Use the <see cref="P:Metadata.ConcatStream.CanRead"/> property to determine whether the
            current instance supports reading. Use the <see cref="M:Metadata.ConcatStream.Read(System.Byte[],System.Int32,System.Int32)"/>
            method to read synchronously from the current stream.
            <para/>
            If streams concatenated before <see cref="P:Metadata.ConcatStream.Position"/> have more
            elements added to them, the output remains unaffected until and
            unless <see cref="P:Metadata.ConcatStream.Position"/> is seeked to before those new
            elements.
            <para/>
            The current position within the stream is advanced by the number
            of bytes read; however, if an exception occurs, the current
            position within the stream remains unchanged. The call will block
            until at least one byte of data can be read, in the event that no
            data is available -- it returns 0 only when there is no more data
            in the stream and no more is expected (such as a closed socket or
            end of file). Fewer bytes than requested may be returned even if
            the end of the stream has not been reached.
            
            TODO: Ensure that the rewind-on-exception occurs properly.
            <para/>
            TODO: If any method could benefit from a test suite, it's this one
            TODO: Should also break into smaller functions
            </remarks>
            
            <param name="buffer">
            When this method returns, the buffer contains the specified byte
            array with the values between offset and (offset + count - 1)
            replaced by the bytes read from the current source.
            </param>
            <param name="offset">
            The zero-based byte offset in buffer at which to begin storing the
            data read from the current stream.
            </param>
            <param name="count">
            The maximum number of bytes to be read from the current stream.
            </param>
            <param name="cancellationToken">
            The token to monitor for cancellation requests. The default value
            is <see cref="P:System.Threading.CancellationToken.None"/>.
            </param>
            
            <returns>
            A task that represents the asynchronous read operation. The value
            is the total number of bytes read into the buffer. This can be less
            than the number of bytes requested if that many bytes are not
            currently available, or zero (0) if the end of the stream has been
            reached.
            </returns>
            
            <exception cref="T:System.ArgumentException">
            The sum of offset and count is larger than the buffer length.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="buffer"/> is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="offset"/> or <paramref name="count"/> is negative.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            The stream is currently in use by a previous read operation.
            
            TODO: Implement this.
            </exception>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support reading.
            </exception>
            
            <seealso cref="M:Metadata.ConcatStream.Read(System.Byte[],System.Int32,System.Int32)"/>
            <seealso cref="M:Metadata.ConcatStream.ReadByte"/>
        </member>
        <member name="M:Metadata.ConcatStream.ReadByte">
            <summary>
            Reads a byte from the stream and advances the position within the
            stream by one byte, or returns -1 if at the end of the stream.
            </summary>
            
            <remarks>
            Use the <see cref="P:Metadata.ConcatStream.CanRead"/> property to determine whether the
            current instance supports reading.
            </remarks>
            
            <returns>
            The unsigned byte cast to an <see cref="T:System.Int32"/>, or -1 if at the
            end of the stream.
            </returns>
            
            <exception cref="T:System.NotSupportedException">
            The stream does not support reading.
            </exception>
            
            <seealso cref="M:Metadata.ConcatStream.Read(System.Byte[],System.Int32,System.Int32)"/>
            <seealso cref="M:Metadata.ConcatStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Metadata.ConcatStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream.
            </summary>
            
            <remarks>
            Use the CanSeek property to determine whether the current instance
            supports seeking.
            <para/>
            If <paramref name="offset"/> is negative, the new position
            precedes the position specified by <paramref name="origin"/> by
            the number of bytes specified by <paramref name="offset"/>. If
            <paramref name="origin"/> is zero (0), the new position is the
            position specified by <paramref name="origin"/>. If
            <paramref name="offset"/> is positive, the new position follows
            the position specified by <paramref name="origin"/> by the number
            of bytes specified by <paramref name="offset"/>.
            <para/>
            Unlike other <see cref="T:System.IO.Stream"/> implementations, seeking to any
            location beyond the length of the stream is <em>not</em> supported.
            
            TODO: See about bringing that into compliance.
            </remarks>
            
            <param name="offset">
            A byte offset relative to the origin parameter.
            </param>
            <param name="origin">
            The reference point used to obtain the new position.
            </param>
            
            <returns>The new position within the current stream.</returns>
            
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support reading.
            </exception>
        </member>
        <member name="M:Metadata.ConcatStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the current stream.
            </summary>
            
            <remarks>
            If the specified value is less than the current length of the
            stream, the stream is truncated. If the specified value is larger
            than the current length of the stream, the stream is expanded. If
            the stream is expanded, the contents of the stream between the old
            and the new length are not defined.
            <para/>
            Use the <see cref="P:Metadata.ConcatStream.CanRead"/> property to determine whether the
            current stream supports writing, and the <see cref="P:Metadata.ConcatStream.CanSeek"/>
            property to determine whether seeking is supported.
            </remarks>
            
            <param name="value">
            The desired length of the current stream in bytes.
            </param>
            
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support both writing and seeking.
            </exception>
        </member>
        <member name="M:Metadata.ConcatStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the current stream and advances the
            current position within this stream by the number of bytes written.
            </summary>
            
            <remarks>
            Use the <see cref="P:Metadata.ConcatStream.CanWrite"/> property to determine whether the
            current instance supports writing. 
            <para/>
            If the write operation is successful, the position within the
            stream advances by the number of bytes written. If an exception
            occurs, the position within the stream remains unchanged.
            
            TODO: Ensure this is properly respected.
            </remarks>
            
            <param name="buffer">
            An array of bytes. This method copies <paramref name="count"/>
            bytes from <paramref name="buffer"/> to the current stream. 
            </param>
            <param name="offset">
            The zero-based byte offset in <paramref name="buffer"/> at which
            to begin copying bytes to the current stream.
            </param>
            <param name="count">
            The number of bytes to be written to the current stream.
            </param>
            
            <exception cref="T:System.ArgumentException">
            The sum of offset and count is larger than the buffer length.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="buffer"/> is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="offset"/> or <paramref name="count"/> is negative.
            </exception>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support reading.
            </exception>
            
            <seealso cref="M:Metadata.ConcatStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/>
            <seealso cref="M:Metadata.ConcatStream.WriteByte(System.Byte)"/>
        </member>
        <member name="M:Metadata.ConcatStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously writes a sequence of bytes to the current stream,
            advances the current position within this stream by the number of
            bytes written, and monitors cancellation requests.
            </summary>
            
            <remarks>
            Use the <see cref="P:Metadata.ConcatStream.CanWrite"/> property to determine whether the
            current instance supports writing. Use the <see cref="M:Metadata.ConcatStream.Write(System.Byte[],System.Int32,System.Int32)"/>
            method to read synchronously from the current stream.
            <para/>
            If the write operation is successful, the position within the
            stream advances by the number of bytes written. If an exception
            occurs, the position within the stream remains unchanged.
            
            TODO: Ensure this is properly respected.
            </remarks>
            
            <param name="buffer">
            An array of bytes. This method copies <paramref name="count"/>
            bytes from <paramref name="buffer"/> to the current stream. 
            </param>
            <param name="offset">
            The zero-based byte offset in <paramref name="buffer"/> at which
            to begin copying bytes to the current stream.
            </param>
            <param name="count">
            The number of bytes to be written to the current stream.
            </param>
            <param name="cancellationToken">
            The token to monitor for cancellation requests. The default value
            is <see cref="P:System.Threading.CancellationToken.None"/>.
            </param>
            
            <returns>
            A task that represents the asynchronous write operation.
            </returns>
            
            <exception cref="T:System.ArgumentException">
            The sum of offset and count is larger than the buffer length.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="buffer"/> is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="offset"/> or <paramref name="count"/> is negative.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            The stream is currently in use by a previous write operation.
            
            TODO: Implement this.
            
            </exception>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support reading.
            </exception>
            
            <seealso cref="M:Metadata.ConcatStream.Write(System.Byte[],System.Int32,System.Int32)"/>
            <seealso cref="M:Metadata.ConcatStream.WriteByte(System.Byte)"/>
        </member>
        <member name="M:Metadata.ConcatStream.WriteByte(System.Byte)">
            <summary>
            Writes a byte to the current position in the stream and advances
            the position within the stream by one byte.
            </summary>
            
            <remarks>
            Use the <see cref="P:Metadata.ConcatStream.CanWrite"/> property to determine whether the
            current instance supports writing.
            </remarks>
            
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support writing.
            </exception>
            
            <seealso cref="M:Metadata.ConcatStream.Write(System.Byte[],System.Int32,System.Int32)"/>
            <seealso cref="M:Metadata.ConcatStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/>
        </member>
        <member name="T:Metadata.MetadataFormat">
            <summary>
            A data-free class providing a common means to work with multiple
            metadata formats.
            </summary>
        </member>
        <member name="F:Metadata.MetadataFormat.tagValidationFunctions">
            <summary>
            Validation functions for each registered metadata format.
            </summary>
            <seealso cref="M:Metadata.MetadataFormat.Validate(System.String,System.IO.Stream)"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Validate(System.String,System.IO.Stream)">
            <summary>
            Check whether the stream begins with metadata in the desired
            format.
            </summary>
            <param name="format">
            The short name of the metadata format.
            </param>
            <param name="stream">The Stream to test.</param>
            <returns>
            Whether the Stream begins with metadata in the desired format.
            </returns>
            <seealso cref="M:Metadata.MetadataFormat.Parse(System.IO.Stream)"/>
        </member>
        <member name="F:Metadata.MetadataFormat.tagFormats">
            <summary>
            The class encapsulating each registered metadata format.
            </summary>
            <seealso cref="M:Metadata.MetadataFormat.FormatType(System.String)"/>
        </member>
        <member name="M:Metadata.MetadataFormat.FormatType(System.String)">
            <summary>
            Retrieve the class implementing the desired metadata format.
            </summary>
            <param name="format">
            The short name of the metadata format.
            </param>
            <returns>The class encapsulating the metadata format.</returns>
            <seealso cref="M:Metadata.MetadataFormat.Construct(System.String,System.IO.Stream)"/>
        </member>
        <member name="F:Metadata.MetadataFormat.assemblies">
            <summary>
            A registry of previously-scanned assemblies in order to prevent
            unnecessary use of reflection methods.
            </summary>
        </member>
        <member name="M:Metadata.MetadataFormat.#cctor">
            <summary>
            Initialize static attributes.
            </summary>
            <seealso cref="M:Metadata.MetadataFormat.RefreshFormats"/>
        </member>
        <member name="M:Metadata.MetadataFormat.RefreshFormats">
            <summary>
            Scan all currently-loaded assemblies for implementations of
            metadata formats.
            </summary>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.Reflection.Assembly)">
            <summary>
            Scan the given assembly for all types marked as implementing a
            metadata format in a suitable manner for automatic lookup.
            <para/>
            Subsequent calls on a previously-scanned assembly will be ignored
            in order to save unnecessary type reflection.
            </summary>
            <param name="assembly">The assembly to scan.</param>
            <seealso cref="T:Metadata.MetadataFormatAttribute"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.Type)">
            <summary>
            Add the given type to the lookup tables according to the descriptor
            specified in its <see cref="P:Metadata.MetadataFormatAttribute.Name"/>.
            </summary>
            <remarks>
            Note that if multiple types are registered under the same name,
            any later registrations will override the previous.
            </remarks>
            <param name="format">The type to add.</param>
            <seealso cref="T:Metadata.MetadataFormatValidatorAttribute"/>
            <seealso cref="M:Metadata.MetadataFormat.FormatType(System.String)"/>
            <seealso cref="M:Metadata.MetadataFormat.Validate(System.String,System.IO.Stream)"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.String,System.Type)">
            <summary>
            Add the given type to the lookup tables under the specified custom
            descriptor, even if it does not have any associated
            <see cref="T:Metadata.MetadataFormatAttribute"/>.
            </summary>
            <remarks>
            The validation function must still be identified with a
            <see cref="T:Metadata.MetadataFormatValidatorAttribute"/>.
            <para/>
            Note that if multiple types are registered under the same name,
            any later registrations will override the previous.
            </remarks>
            <param name="name">
            A short name for the format to be used as an access key for later
            lookups.
            <para/>
            It is recommended that this also be exposed as a constant.
            </param>
            <param name="format">The type to add.</param>
            <seealso cref="M:Metadata.MetadataFormat.FormatType(System.String)"/>
            <seealso cref="M:Metadata.MetadataFormat.Validate(System.String,System.IO.Stream)"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Register(System.String,System.Reflection.MethodInfo)">
            <summary>
            Add the given method to the lookup tables under the specified
            custom descriptor.
            <para/>
            This should almost purely be called via
            <see cref="M:Metadata.MetadataFormat.Register(System.String,System.Type)"/>, and has been separated
            primarily for code clarity.
            </summary>
            <remarks>
            Note that if multiple methods are registered under the same name,
            any later registrations will override the previous.
            </remarks>
            <param name="name">
            A short name for the format to be used as an access key for later
            lookups.
            </param>
            <param name="method">The method to add.</param>
        </member>
        <member name="M:Metadata.MetadataFormat.Parse(System.IO.Stream)">
            <summary>
            Check the stream against all registered tag formats, and return
            those that match the header.
            </summary>
            <remarks>
            While, in theory, only a single header should match, the class
            structure is such that this is not a restriction; supporting this
            feature allows for nonstandard usages without exclusive headers.
            
            The callee is left to determine the best means of handling the
            case of Detect(...).Count > 1.
            </remarks>
            <param name="stream">The bytestream to test.</param>
            <returns>The keys of all matching formats.</returns>
            <seealso cref="M:Metadata.MetadataFormat.Validate(System.String,System.IO.Stream)"/>
        </member>
        <member name="M:Metadata.MetadataFormat.Construct(System.String,System.IO.Stream)">
            <summary>
            Parse metadata in the desired format from the current position in
            a stream.
            </summary>
            <param name="format">
            The short name of the metadata format.
            </param>
            <param name="stream">The bytestream to parse.</param>
            <returns>The parsed metadata.</returns>
            <seealso cref="M:Metadata.MetadataFormat.FormatType(System.String)"/>
        </member>
        <member name="T:Metadata.MetadataFormat.ITagFormat">
            <summary>
            Common properties to retrieve info from multiple tag formats.
            </summary>
        </member>
        <member name="P:Metadata.MetadataFormat.ITagFormat.Format">
            <summary>
            The display name of the tag format.
            </summary>
        </member>
        <member name="P:Metadata.MetadataFormat.ITagFormat.Attributes">
            <summary>
            The proper standardized field redirects for the enclosing
            metadata format.
            </summary>
        </member>
        <member name="T:Metadata.MetadataFormatAssemblyAttribute">
            <summary>
            Indicate that the assembly should be scanned for classes marked with
            <see cref="T:Metadata.MetadataFormatAttribute"/> to automatically register.
            
            This class cannot be inherited.
            </summary>
            <seealso cref="T:Metadata.MetadataFormatAttribute"/>
            <seealso cref="M:Metadata.MetadataFormat.Register(System.Reflection.Assembly)"/>
        </member>
        <member name="T:Metadata.MetadataFormatAttribute">
            <summary>
            Indicate that the class implements a metadata format specification.
            
            This class cannot be inherited.
            </summary>
            <remarks>
            The class must implement <see cref="T:Metadata.MetadataFormat.ITagFormat"/>.
            </remarks>
            <seealso cref="T:Metadata.MetadataFormatAssemblyAttribute"/>
            <seealso cref="M:Metadata.MetadataFormat.Register(System.String,System.Type)"/>
        </member>
        <member name="P:Metadata.MetadataFormatAttribute.Name">
            <summary>
            The unique short name representing this format.
            </summary>
        </member>
        <member name="M:Metadata.MetadataFormatAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Metadata.MetadataFormatAttribute"/> class with the specified
            <see cref="P:Metadata.MetadataFormatAttribute.Name"/>.
            </summary>
            <param name="name">
            The unique short name representing this format.
            <para/>
            It is recommended that this also be exposed as a constant on the
            type itself.
            </param>
        </member>
        <member name="T:Metadata.MetadataFormatValidatorAttribute">
            <summary>
            Marks a method as being a validation function checking a binary header
            against that defined by the enclosing metadata specification.
            
            This class cannot be inherited.
            </summary>
            <remarks>
            Note that this function must be able to accept only a
            <see cref="T:System.IO.Stream"/> and return a <see cref="T:System.Boolean"/>,
            while leaving <see cref="P:System.IO.Stream.Position"/> with the same
            (potentially non-0) value as it had before the function was called.
            
            This may change according to the TODO within
            <see cref="!:MetadataFormat.Detect(System.IO.Stream)"/>, likely by
            adding a `HeaderLength` parameter to this attribute.
            </remarks>
            TODO: Add discussion of required signature according to exceptions in
            method Register(...)
        </member>
        <member name="T:Metadata.TagAttributes">
            <summary>
            Common format-agnostic attributes mapping to different fields
            depending on how each is expressed in the particular format.
            </summary>
        </member>
        <member name="P:Metadata.TagAttributes.Name">
            <summary>
            The display name of the file.
            </summary>
        </member>
    </members>
</doc>
